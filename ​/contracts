// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title AuraAI_Inference_Oracle
 * @author Alex Medoff | AURA AI Ecosystem
 * @dev Proof-of-Inference Layer for BNB Chain "Good Vibes Only" Hackathon.
 * This contract anchors AI-generated signals into the blockchain for immutable verification.
 */
contract AuraCore {
    address public immutable owner;
    uint256 public totalInferences;

    struct Inference {
        string asset;         // Asset ticker (e.g., "BNB", "SOL")
        bytes32 forecastHash; // SHA-256 hash of the neural output
        uint256 confidence;   // Model confidence (0-100)
        uint256 timestamp;    // Block timestamp
        bool verified;        // Accuracy verification status
    }

    // Mapping of unique Inference IDs to their metadata
    mapping(bytes32 => Inference) public inferences;
    
    event NewInference(bytes32 indexed queryId, string asset, uint256 confidence);
    event InferenceVerified(bytes32 indexed queryId, bool success);

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "AURA_AUTH_FAILURE");
        _;
    }

    /**
     * @dev Commits AI-generated inference to the BNB Chain.
     * @param _asset Ticker of the analyzed asset.
     * @param _forecastHash The hash generated by the A.X.E.L. engine.
     * @param _confidence Confidence level (0-100).
     */
    function commitInference(
        string calldata _asset, 
        bytes32 _forecastHash, 
        uint256 _confidence
    ) external onlyOwner returns (bytes32) {
        // Generating a unique ID for the proof
        bytes32 queryId = keccak256(abi.encodePacked(_asset, _forecastHash, block.timestamp));
        
        inferences[queryId] = Inference({
            asset: _asset,
            forecastHash: _forecastHash,
            confidence: _confidence,
            timestamp: block.timestamp,
            verified: false
        });

        totalInferences++;
        emit NewInference(queryId, _asset, _confidence);
        return queryId;
    }

    /**
     * @dev Updates the verification status of a specific inference.
     * @param _queryId The unique ID of the inference.
     * @param _success Result of the market outcome.
     */
    function verifyInference(bytes32 _queryId, bool _success) external onlyOwner {
        require(inferences[_queryId].timestamp != 0, "INFERENCE_NOT_FOUND");
        inferences[_queryId].verified = _success;
        emit InferenceVerified(_queryId, _success);
    }

    /**
     * @dev Returns inference data for external validation.
     */
    function getInference(bytes32 _queryId) external view returns (Inference memory) {
        return inferences[_queryId];
    }
}
